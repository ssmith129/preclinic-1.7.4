# Untitled

```markdown
markdown

# PreClinic Platform
## AI Features Implementation Guide
### *Detailed Technical Specifications & Code*

---

**Features Covered:**
- Feature 7: AI-Powered Shift Handoff
- Feature 9: Voice Documentation Assistant
- Feature 10: Drug Interaction Checker
**Date:** February 2026  
**Version:** 2.0

---

## üìÅ Project Structure

Before implementing the features, establish the following directory structure:

```
src/
‚îú‚îÄ‚îÄ feature-module/
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îî‚îÄ‚îÄ ai/
‚îÇ           ‚îú‚îÄ‚îÄ shift-handoff/
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ ShiftHandoffSummary.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ SBARGenerator.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ PatientHandoffCard.tsx
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ HandoffTimeline.tsx
‚îÇ           ‚îú‚îÄ‚îÄ voice-documentation/
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ VoiceRecorder.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ TranscriptionEditor.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ NoteFormatter.tsx
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ MedicalTermsHighlighter.tsx
‚îÇ           ‚îú‚îÄ‚îÄ drug-interaction/
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ DrugInteractionChecker.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ InteractionAlert.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ MedicationReviewPanel.tsx
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ SeverityBadge.tsx
‚îÇ           ‚îú‚îÄ‚îÄ patient-summary/
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ PatientHistorySummarizer.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ DiagnosisTimeline.tsx
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ TreatmentHighlights.tsx
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ TrendAnalysisChart.tsx
‚îÇ           ‚îî‚îÄ‚îÄ ai-assistant/
‚îÇ               ‚îú‚îÄ‚îÄ AIAssistantButton.tsx
‚îÇ               ‚îú‚îÄ‚îÄ AIAssistantPopup.tsx
‚îÇ               ‚îú‚îÄ‚îÄ AssistantChatInterface.tsx
‚îÇ               ‚îú‚îÄ‚îÄ QuickActionCards.tsx
‚îÇ               ‚îî‚îÄ‚îÄ NavigationHelper.tsx
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ redux/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ shiftHandoffSlice.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ voiceDocSlice.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ drugInteractionSlice.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ patientSummarySlice.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ aiAssistantSlice.ts
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mock/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ shiftHandoffMockApi.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ voiceDocMockApi.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ drugInteractionMockApi.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ patientSummaryMockApi.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ aiAssistantMockApi.ts
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ useVoiceRecognition.ts
‚îÇ       ‚îú‚îÄ‚îÄ useDrugInteraction.ts
‚îÇ       ‚îî‚îÄ‚îÄ useAIAssistant.ts
‚îî‚îÄ‚îÄ style/
    ‚îî‚îÄ‚îÄ scss/
        ‚îî‚îÄ‚îÄ components/
            ‚îî‚îÄ‚îÄ ai/
                ‚îú‚îÄ‚îÄ _shift-handoff.scss
                ‚îú‚îÄ‚îÄ _voice-documentation.scss
                ‚îú‚îÄ‚îÄ _drug-interaction.scss
                ‚îú‚îÄ‚îÄ _patient-summary.scss
                ‚îî‚îÄ‚îÄ _ai-assistant.scss
```

```markdown
## Feature 7: AI-Powered Shift Handoff

### Problem Statement

Manual shift handoffs between nursing staff are time-consuming (15-30 minutes per shift) and prone to information gaps. Critical patient details may be missed, leading to delayed interventions or duplicated efforts. There's no standardized format ensuring consistent communication quality.

### AI Solution

Implement an automated SBAR (Situation, Background, Assessment, Recommendation) generation system that:
- Aggregates patient data from the past 8-12 hours
- Identifies critical changes and trends using NLP
- Generates structured handoff summaries
- Highlights priority patients requiring immediate attention
- Provides audio playback option for hands-free review

### Technical Requirements

| Component | Description |
|-----------|-------------|
| **React Components** | `ShiftHandoffSummary.tsx`, `SBARGenerator.tsx`, `PatientHandoffCard.tsx`, `HandoffTimeline.tsx` |
| **Redux Slice** | `shiftHandoffSlice.ts` (handoff data, generation status, preferences) |
| **API Endpoints** | `POST /api/handoff/generate`, `GET /api/handoff/patients/:shiftId`, `PUT /api/handoff/acknowledge` |
| **AI Integration** | GPT-4 for narrative generation, custom model for priority scoring |

### Mock API Engine

```typescript
// src/core/api/mock/shiftHandoffMockApi.ts
import { v4 as uuidv4 } from 'uuid';

export interface PatientHandoff {
  patientId: string;
  patientName: string;
  room: string;
  age: number;
  admissionDate: string;
  primaryDiagnosis: string;
  priorityLevel: 'critical' | 'high' | 'moderate' | 'stable';
  sbar: {
    situation: string;
    background: string;
    assessment: string;
    recommendation: string;
  };
  vitalsTrend: {
    metric: string;
    values: number[];
    timestamps: string[];
    trend: 'improving' | 'stable' | 'declining';
  }[];
  recentEvents: {
    time: string;
    event: string;
    severity: 'info' | 'warning' | 'critical';
  }[];
  pendingTasks: string[];
  medications: {
    name: string;
    dose: string;
    nextDue: string;
    notes?: string;
  }[];
}

export interface ShiftHandoffReport {
  reportId: string;
  generatedAt: string;
  shiftType: 'day' | 'evening' | 'night';
  outgoingNurse: { id: string; name: string };
  incomingNurse: { id: string; name: string };
  unitName: string;
  totalPatients: number;
  criticalPatients: number;
  patients: PatientHandoff[];
  summaryNarrative: string;
  audioUrl?: string;
}

// Mock patient data generator
const generateMockPatientHandoff = (index: number): PatientHandoff => {
  const priorities: PatientHandoff['priorityLevel'][] = ['critical', 'high', 'moderate', 'stable'];
  const diagnoses = [
    'Pneumonia with respiratory distress',
    'Post-operative hip replacement - Day 2',
    'Diabetic ketoacidosis - resolving',
    'Congestive heart failure exacerbation',
    'Acute appendicitis - post-appendectomy',
    'Stroke - left MCA territory',
    'COPD exacerbation',
    'Sepsis - improving on antibiotics'
  ];

  const priority = priorities[Math.min(index, 3)];
  
  const sbarTemplates = {
    critical: {
      situation: `Patient experiencing acute respiratory distress with SpO2 dropping to 88% on 4L NC. RR elevated to 28. Patient appears anxious and using accessory muscles.`,
      background: `72-year-old male admitted 3 days ago with community-acquired pneumonia. History of COPD, HTN, and type 2 diabetes. Was stable on 2L NC until 2 hours ago.`,
      assessment: `Likely worsening pneumonia vs. new PE. Current ABG shows respiratory acidosis. Chest X-ray pending. Patient is at high risk for intubation.`,
      recommendation: `Increase O2 to high-flow NC, stat ABG in 1 hour, prepare for possible BiPAP or intubation. Notify physician immediately if SpO2 drops below 85%.`
    },
    high: {
      situation: `Patient reporting increased pain at surgical site (7/10) despite scheduled pain medication. Mild fever of 100.8¬∞F noted this shift.`,
      background: `58-year-old female, POD 2 from total hip arthroplasty. No known allergies. Was ambulating well yesterday with PT.`,
      assessment: `Pain increase and low-grade fever concerning for possible surgical site infection. Incision appears slightly erythematous.`,
      recommendation: `Monitor temp q4h, obtain wound culture if drainage noted, contact orthopedics if fever persists. Continue current pain management protocol.`
    },
    moderate: {
      situation: `Patient's blood glucose levels fluctuating between 180-320 mg/dL despite sliding scale insulin adjustments.`,
      background: `45-year-old male admitted for DKA, now resolved. A1C on admission was 12.4%. New to insulin therapy.`,
      assessment: `Glycemic control improving but not yet optimal. Patient anxious about self-injection and carb counting.`,
      recommendation: `Continue current insulin regimen, diabetes educator consult scheduled for tomorrow. Reinforce teaching on injection technique.`
    },
    stable: {
      situation: `Patient resting comfortably, vital signs stable throughout shift. Tolerating regular diet, ambulating independently.`,
      background: `34-year-old female, POD 1 from laparoscopic cholecystectomy. No complications intraoperatively.`,
      assessment: `Recovering as expected. Pain well-controlled with oral medications. Ready for discharge pending surgeon evaluation.`,
      recommendation: `Continue current care plan. Anticipate discharge today after surgical team rounds. Ensure discharge instructions reviewed.`
    }
  };

  return {
    patientId: uuidv4(),
    patientName: `Patient ${String.fromCharCode(65 + index)}. ${['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis'][index % 8]}`,
    room: `${Math.floor(200 + index * 2)}${['A', 'B'][index % 2]}`,
    age: 35 + Math.floor(Math.random() * 50),
    admissionDate: new Date(Date.now() - (Math.random() * 7 * 24 * 60 * 60 * 1000)).toISOString(),
    primaryDiagnosis: diagnoses[index % diagnoses.length],
    priorityLevel: priority,
    sbar: sbarTemplates[priority],
    vitalsTrend: [
      {
        metric: 'Heart Rate',
        values: Array.from({ length: 6 }, () => 70 + Math.floor(Math.random() * 30)),
        timestamps: Array.from({ length: 6 }, (_, i) => 
          new Date(Date.now() - (5 - i) * 2 * 60 * 60 * 1000).toISOString()
        ),
        trend: ['improving', 'stable', 'declining'][Math.floor(Math.random() * 3)] as any
      },
      {
        metric: 'Blood Pressure',
        values: Array.from({ length: 6 }, () => 110 + Math.floor(Math.random() * 40)),
        timestamps: Array.from({ length: 6 }, (_, i) => 
          new Date(Date.now() - (5 - i) * 2 * 60 * 60 * 1000).toISOString()
        ),
        trend: ['improving', 'stable', 'declining'][Math.floor(Math.random() * 3)] as any
      }
    ],
    recentEvents: [
      { time: '14:30', event: 'Medication administered - Lisinopril 10mg', severity: 'info' },
      { time: '12:00', event: 'Patient ambulated 100ft with assistance', severity: 'info' },
      ...(priority === 'critical' ? [{ time: '15:45', event: 'Rapid Response Team called', severity: 'critical' as const }] : [])
    ],
    pendingTasks: [
      'Evening vitals due at 20:00',
      'Blood glucose check before dinner',
      ...(priority !== 'stable' ? ['Physician notification required'] : [])
    ],
    medications: [
      { name: 'Metoprolol', dose: '25mg PO', nextDue: '20:00', notes: 'Hold if HR < 60' },
      { name: 'Insulin Glargine', dose: '20 units SC', nextDue: '21:00' },
      { name: 'Acetaminophen', dose: '650mg PO', nextDue: 'PRN', notes: 'Q6H for pain' }
    ]
  };
};

// Simulate AI narrative generation
const generateSummaryNarrative = (patients: PatientHandoff[]): string => {
  const critical = patients.filter(p => p.priorityLevel === 'critical').length;
  const high = patients.filter(p => p.priorityLevel === 'high').length;
  
  return `This shift report covers ${patients.length} patients on the Medical-Surgical unit. ` +
    `${critical > 0 ? `‚ö†Ô∏è ${critical} patient(s) require immediate attention. ` : ''}` +
    `${high > 0 ? `${high} patient(s) are flagged as high priority. ` : ''}` +
    `Key concerns this shift include respiratory status monitoring for Room 200A, ` +
    `post-operative pain management in Room 202B, and glycemic control for Room 204A. ` +
    `All scheduled medications have been administered. ` +
    `No falls or safety incidents occurred during this shift.`;
};

// Mock API functions
export const shiftHandoffMockApi = {
  generateHandoffReport: async (params: {
    outgoingNurseId: string;
    incomingNurseId: string;
    shiftType: 'day' | 'evening' | 'night';
    unitId: string;
  }): Promise => {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1500));

    const patientCount = 4 + Math.floor(Math.random() * 4);
    const patients = Array.from({ length: patientCount }, (_, i) => generateMockPatientHandoff(i));
    
    // Sort by priority
    patients.sort((a, b) => {
      const priorityOrder = { critical: 0, high: 1, moderate: 2, stable: 3 };
      return priorityOrder[a.priorityLevel] - priorityOrder[b.priorityLevel];
    });

    return {
      reportId: uuidv4(),
      generatedAt: new Date().toISOString(),
      shiftType: params.shiftType,
      outgoingNurse: { id: params.outgoingNurseId, name: 'Sarah Mitchell, RN' },
      incomingNurse: { id: params.incomingNurseId, name: 'James Chen, RN' },
      unitName: 'Medical-Surgical Unit 3B',
      totalPatients: patients.length,
      criticalPatients: patients.filter(p => p.priorityLevel === 'critical').length,
      patients,
      summaryNarrative: generateSummaryNarrative(patients),
      audioUrl: '/api/audio/handoff-summary.mp3'
    };
  },

  acknowledgeHandoff: async (reportId: string, nurseId: string): Promise => {
    await new Promise(resolve => setTimeout(resolve, 500));
    return {
      success: true,
      timestamp: new Date().toISOString()
    };
  },

  getHandoffHistory: async (nurseId: string, days: number = 7): Promise => {
    await new Promise(resolve => setTimeout(resolve, 800));
    return []; // Return empty for mock
  }
};
```

### Redux Slice

```typescript
// src/core/redux/shiftHandoffSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { shiftHandoffMockApi, ShiftHandoffReport, PatientHandoff } from '../api/mock/shiftHandoffMockApi';

interface ShiftHandoffState {
  currentReport: ShiftHandoffReport | null;
  isGenerating: boolean;
  isAcknowledged: boolean;
  selectedPatient: PatientHandoff | null;
  audioPlaying: boolean;
  error: string | null;
  preferences: {
    autoPlayAudio: boolean;
    expandedView: boolean;
    showVitalsTrends: boolean;
  };
}

const initialState: ShiftHandoffState = {
  currentReport: null,
  isGenerating: false,
  isAcknowledged: false,
  selectedPatient: null,
  audioPlaying: false,
  error: null,
  preferences: {
    autoPlayAudio: false,
    expandedView: true,
    showVitalsTrends: true
  }
};

export const generateHandoffReport = createAsyncThunk(
  'shiftHandoff/generate',
  async (params: {
    outgoingNurseId: string;
    incomingNurseId: string;
    shiftType: 'day' | 'evening' | 'night';
    unitId: string;
  }) => {
    return await shiftHandoffMockApi.generateHandoffReport(params);
  }
);

export const acknowledgeHandoff = createAsyncThunk(
  'shiftHandoff/acknowledge',
  async (params: { reportId: string; nurseId: string }) => {
    return await shiftHandoffMockApi.acknowledgeHandoff(params.reportId, params.nurseId);
  }
);

const shiftHandoffSlice = createSlice({
  name: 'shiftHandoff',
  initialState,
  reducers: {
    selectPatient: (state, action: PayloadAction) => {
      state.selectedPatient = action.payload;
    },
    toggleAudio: (state) => {
      state.audioPlaying = !state.audioPlaying;
    },
    updatePreferences: (state, action: PayloadAction<Partial>) => {
      state.preferences = { ...state.preferences, ...action.payload };
    },
    clearReport: (state) => {
      state.currentReport = null;
      state.isAcknowledged = false;
      state.selectedPatient = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(generateHandoffReport.pending, (state) => {
        state.isGenerating = true;
        state.error = null;
      })
      .addCase(generateHandoffReport.fulfilled, (state, action) => {
        state.isGenerating = false;
        state.currentReport = action.payload;
      })
      .addCase(generateHandoffReport.rejected, (state, action) => {
        state.isGenerating = false;
        state.error = action.error.message || 'Failed to generate report';
      })
      .addCase(acknowledgeHandoff.fulfilled, (state) => {
        state.isAcknowledged = true;
      });
  }
});

export const { selectPatient, toggleAudio, updatePreferences, clearReport } = shiftHandoffSlice.actions;
export default shiftHandoffSlice.reducer;
```

### Main Component Implementation

```tsx
// src/feature-module/components/ai/shift-handoff/ShiftHandoffSummary.tsx
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { 
  Card, 
  Button, 
  Tag, 
  Timeline, 
  Progress, 
  Tooltip, 
  Modal, 
  Spin, 
  Alert,
  Badge,
  Tabs,
  Switch,
  Statistic,
  Row,
  Col
} from 'antd';
import {
  SoundOutlined,
  PauseOutlined,
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  ClockCircleOutlined,
  UserOutlined,
  HeartOutlined,
  MedicineBoxOutlined
} from '@ant-design/icons';
import { 
  generateHandoffReport, 
  acknowledgeHandoff, 
  selectPatient, 
  toggleAudio 
} from '../../../../core/redux/shiftHandoffSlice';
import { PatientHandoffCard } from './PatientHandoffCard';
import { SBARGenerator } from './SBARGenerator';
import { HandoffTimeline } from './HandoffTimeline';
import type { RootState, AppDispatch } from '../../../../core/redux/store';

const { TabPane } = Tabs;

interface ShiftHandoffSummaryProps {
  outgoingNurseId: string;
  incomingNurseId: string;
  shiftType: 'day' | 'evening' | 'night';
  unitId: string;
}

const PRIORITY_CONFIG = {
  critical: { color: '#F44336', icon: , label: 'Critical' },
  high: { color: '#FF9800', icon: , label: 'High' },
  moderate: { color: '#FFC107', icon: , label: 'Moderate' },
  stable: { color: '#4CAF50', icon: , label: 'Stable' }
};

export const ShiftHandoffSummary: React.FC = ({
  outgoingNurseId,
  incomingNurseId,
  shiftType,
  unitId
}) => {
  const dispatch = useDispatch();
  const { 
    currentReport, 
    isGenerating, 
    isAcknowledged, 
    selectedPatient,
    audioPlaying,
    preferences,
    error 
  } = useSelector((state: RootState) => state.shiftHandoff);
  
  const [detailModalVisible, setDetailModalVisible] = useState(false);

  useEffect(() => {
    dispatch(generateHandoffReport({ outgoingNurseId, incomingNurseId, shiftType, unitId }));
  }, [dispatch, outgoingNurseId, incomingNurseId, shiftType, unitId]);

  const handleAcknowledge = () => {
    if (currentReport) {
      dispatch(acknowledgeHandoff({ reportId: currentReport.reportId, nurseId: incomingNurseId }));
    }
  };

  const handlePatientClick = (patient: any) => {
    dispatch(selectPatient(patient));
    setDetailModalVisible(true);
  };

  const getShiftLabel = (type: string) => ({
    day: '‚òÄÔ∏è Day Shift (7AM - 3PM)',
    evening: 'üåÖ Evening Shift (3PM - 11PM)',
    night: 'üåô Night Shift (11PM - 7AM)'
  }[type]);

  if (isGenerating) {
    return (
      
        
          
          Generating AI-Powered Shift Handoff Report
          
            Analyzing patient data, vital trends, and recent events...
          
          
        
      
    );
  }

  if (error) {
    return (
      <Alert
        type="error"
        message="Failed to Generate Handoff Report"
        description={error}
        showIcon
        action={
          <Button onClick={() => dispatch(generateHandoffReport({ outgoingNurseId, incomingNurseId, shiftType, unitId }))}>
            Retry
          
        }
      />
    );
  }

  if (!currentReport) return null;

  return (
    
      {/* Header Section */}
      
        
          
            
              
                
              
              
                AI-Generated Shift Handoff
                
                  {getShiftLabel(currentReport.shiftType)} ‚Ä¢ {currentReport.unitName}
                
              
            
          
          
            
               : }
                onClick={() => dispatch(toggleAudio())}
              >
                {audioPlaying ? 'Pause Audio' : 'Play Summary'}
              
              }
                onClick={handleAcknowledge}
                disabled={isAcknowledged}
              >
                {isAcknowledged ? 'Acknowledged ‚úì' : 'Acknowledge Handoff'}
              
            
          
        

        {/* Nurse Transfer Info */}
        
          
            
              
                
                Outgoing: {currentReport.outgoingNurse.name}
              
            
            
              
            
            
              
                
                Incoming: {currentReport.incomingNurse.name}
              
            
          
        
      

      {/* Statistics Overview */}
      
        
          
            }
            />
          
        
        
          
            }
            />
          
        
        
          
            <Statistic 
              title="High Priority" 
              value={currentReport.patients.filter(p => p.priorityLevel === 'high').length}
              valueStyle={{ color: '#FF9800' }}
              prefix={}
            />
          
        
        
          
            <Statistic 
              title="Stable" 
              value={currentReport.patients.filter(p => p.priorityLevel === 'stable').length}
              valueStyle={{ color: '#4CAF50' }}
              prefix={}
            />
          
        
      

      {/* AI Summary Narrative */}
      
        
          
            
          
          
            AI Summary
            {currentReport.summaryNarrative}
          
        
      

      {/* Patient Cards */}
      
        
          
            {currentReport.patients.map((patient) => (
              
                <PatientHandoffCard 
                  patient={patient}
                  onClick={() => handlePatientClick(patient)}
                  priorityConfig={PRIORITY_CONFIG}
                />
              
            ))}
          
        
        
              
                Critical & High Priority
              
            
          } 
          key="priority"
        >
          
            {currentReport.patients
              .filter(p => p.priorityLevel === 'critical' || p.priorityLevel === 'high')
              .map((patient) => (
                
                  <PatientHandoffCard 
                    patient={patient}
                    onClick={() => handlePatientClick(patient)}
                    priorityConfig={PRIORITY_CONFIG}
                    expanded
                  />
                
              ))}
          
        
      

      {/* Patient Detail Modal */}
      
            
              {PRIORITY_CONFIG[selectedPatient?.priorityLevel || 'stable'].label}
            
            {selectedPatient?.patientName} - Room {selectedPatient?.room}
          
        }
        open={detailModalVisible}
        onCancel={() => setDetailModalVisible(false)}
        width={800}
        footer={null}
      >
        {selectedPatient && (
          
        )}
      
    
  );
};
```

### Patient Handoff Card Component

```tsx
// src/feature-module/components/ai/shift-handoff/PatientHandoffCard.tsx
import React from 'react';
import { Card, Tag, Timeline, Progress, Tooltip, List } from 'antd';
import { 
  HeartOutlined, 
  MedicineBoxOutlined,
  AlertOutlined,
  ClockCircleOutlined
} from '@ant-design/icons';
import type { PatientHandoff } from '../../../../core/api/mock/shiftHandoffMockApi';

interface PatientHandoffCardProps {
  patient: PatientHandoff;
  onClick: () => void;
  priorityConfig: Record;
  expanded?: boolean;
}

export const PatientHandoffCard: React.FC = ({
  patient,
  onClick,
  priorityConfig,
  expanded = false
}) => {
  const config = priorityConfig[patient.priorityLevel];
  
  const getTrendIcon = (trend: string) => {
    switch (trend) {
      case 'improving': return ‚Üë;
      case 'declining': return ‚Üì;
      default: return ‚Üí;
    }
  };

  return (
    
      {/* Header */}
      
        
          {patient.patientName}
          
            Room {patient.room} ‚Ä¢ {patient.age} y/o
          
        
        
          {config.label}
        
      

      {/* Primary Diagnosis */}
      
        
        {patient.primaryDiagnosis}
      

      {/* Quick SBAR Preview */}
      
        
          S: {patient.sbar.situation.slice(0, 80)}...
        
      

      {/* Vitals Trend Indicators */}
      
        
          {patient.vitalsTrend.slice(0, 2).map((vital, idx) => (
            
              
                
                {vital.metric.slice(0, 2)} {getTrendIcon(vital.trend)}
              
            
          ))}
        
      

      {/* Pending Tasks Count */}
      
        
          
          {patient.pendingTasks.length} pending task(s)
        
        
          
          {patient.medications.length} meds
        
      

      {/* Recent Critical Events */}
      {patient.recentEvents.filter(e => e.severity === 'critical').length > 0 && (
        
          
          
            {patient.recentEvents.filter(e => e.severity === 'critical')[0].event}
          
        
      )}

      {/* Expanded View */}
      {expanded && (
        
          Recent Events
          
            {patient.recentEvents.map((event, idx) => (
              <Timeline.Item 
                key={idx} 
                color={event.severity === 'critical' ? 'red' : event.severity === 'warning' ? 'orange' : 'gray'}
              >
                {event.time}
                {event.event}
              
            ))}
          
        
      )}
    
  );
};
```

### SBAR Generator Component

```tsx
// src/feature-module/components/ai/shift-handoff/SBARGenerator.tsx
import React from 'react';
import { Card, Tabs, List, Tag, Timeline, Divider } from 'antd';
import { 
  AlertOutlined, 
  HistoryOutlined, 
  FileSearchOutlined, 
  BulbOutlined,
  MedicineBoxOutlined,
  CheckSquareOutlined
} from '@ant-design/icons';
import { Line } from '@ant-design/charts';
import type { PatientHandoff } from '../../../../core/api/mock/shiftHandoffMockApi';

const { TabPane } = Tabs;

interface SBARGeneratorProps {
  patient: PatientHandoff;
}

export const SBARGenerator: React.FC = ({ patient }) => {
  // Prepare vitals chart data
  const vitalsChartData = patient.vitalsTrend.flatMap(vital => 
    vital.values.map((value, idx) => ({
      time: new Date(vital.timestamps[idx]).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
      value,
      metric: vital.metric
    }))
  );

  const chartConfig = {
    data: vitalsChartData,
    xField: 'time',
    yField: 'value',
    seriesField: 'metric',
    smooth: true,
    height: 200,
    legend: { position: 'top' as const }
  };

  const sbarSections = [
    { 
      key: 'situation', 
      title: 'Situation', 
      icon: ,
      content: patient.sbar.situation,
      color: '#F44336'
    },
    { 
      key: 'background', 
      title: 'Background', 
      icon: ,
      content: patient.sbar.background,
      color: '#2196F3'
    },
    { 
      key: 'assessment', 
      title: 'Assessment', 
      icon: ,
      content: patient.sbar.assessment,
      color: '#FF9800'
    },
    { 
      key: 'recommendation', 
      title: 'Recommendation', 
      icon: ,
      content: patient.sbar.recommendation,
      color: '#4CAF50'
    }
  ];

  return (
    
      
        
          
            {sbarSections.map((section) => (
              
                
                  
                    {section.icon}
                  
                  
                    
                      {section.title}
                    
                    {section.content}
                  
                
              
            ))}
          
        

        
          
            12-Hour Vitals Trend
            
            
            
              {patient.vitalsTrend.map((vital, idx) => (
                <Tag 
                  key={idx}
                  color={vital.trend === 'improving' ? 'green' : vital.trend === 'declining' ? 'red' : 'default'}
                >
                  {vital.metric}: {vital.trend}
                
              ))}
            
          
        

        
          <List
            dataSource={patient.medications}
            renderItem={(med) => (
              
                }
                  title={{med.name}}
                  description={
                    
                      Dose: {med.dose}
                      Next Due: {med.nextDue}
                      {med.notes && ‚ö†Ô∏è {med.notes}}
                    
                  }
                />
              
            )}
          />
        

        
          <List
            dataSource={patient.pendingTasks}
            renderItem={(task, idx) => (
              
                
                {task}
              
            )}
          />
        

        
          
            {patient.recentEvents.map((event, idx) => (
              <Timeline.Item 
                key={idx}
                color={event.severity === 'critical' ? 'red' : event.severity === 'warning' ? 'orange' : 'gray'}
                label={event.time}
              >
                {event.event}
              
            ))}
          
        
      
    
  );
};
```
```

```markdown

## Feature 10: Drug Interaction Checker

### Problem Statement

Physicians and nurses manually review medication lists for potential interactions, which is time-consuming and error-prone. Critical drug-drug and drug-condition interactions may be missed, leading to adverse events. Current systems lack real-time alerts during the prescribing workflow.

### AI Solution

Real-time drug interaction checking system that analyzes new prescriptions against the patient's current medication list, allergies, and conditions. Provides severity-coded alerts with clinical recommendations and alternative medication suggestions.

### Technical Requirements

| Component | Description |
|-----------|-------------|
| **React Components** | `DrugInteractionChecker.tsx`, `InteractionAlert.tsx`, `MedicationReviewPanel.tsx`, `SeverityBadge.tsx` |
| **Redux Slice** | `drugInteractionSlice.ts` (medications, interactions, alerts) |
| **API Endpoints** | `POST /api/drugs/check-interaction`, `GET /api/drugs/alternatives`, `GET /api/patient/:id/medications` |
| **AI Integration** | Drug interaction database, NLP for contraindication analysis |

### Mock API Engine

```typescript
// src/core/api/mock/drugInteractionMockApi.ts
import { v4 as uuidv4 } from 'uuid';

export interface Medication {
  id: string;
  name: string;
  genericName: string;
  dosage: string;
  frequency: string;
  route: string;
  startDate: string;
  prescriber: string;
  status: 'active' | 'discontinued' | 'pending';
}

export interface DrugInteraction {
  id: string;
  drug1: { name: string; id: string };
  drug2: { name: string; id: string };
  severity: 'contraindicated' | 'severe' | 'moderate' | 'minor';
  mechanism: string;
  clinicalEffect: string;
  recommendation: string;
  documentation: 'excellent' | 'good' | 'fair';
  alternatives: { name: string; rationale: string }[];
}

export interface AllergyInteraction {
  id: string;
  drug: { name: string; id: string };
  allergen: string;
  reactionType: string;
  severity: 'severe' | 'moderate' | 'mild';
  crossReactivity: boolean;
  recommendation: string;
}

export interface ConditionInteraction {
  id: string;
  drug: { name: string; id: string };
  condition: string;
  severity: 'contraindicated' | 'severe' | 'moderate' | 'minor';
  clinicalConcern: string;
  recommendation: string;
}

export interface InteractionCheckResult {
  checkId: string;
  timestamp: string;
  newMedication: Medication;
  drugInteractions: DrugInteraction[];
  allergyInteractions: AllergyInteraction[];
  conditionInteractions: ConditionInteraction[];
  overallRisk: 'high' | 'moderate' | 'low' | 'none';
  canProceed: boolean;
  requiresOverride: boolean;
}

// Mock drug interaction database
const INTERACTION_DATABASE: Record>> = {
  'warfarin': {
    'aspirin': {
      severity: 'severe',
      mechanism: 'Additive anticoagulant effects and increased risk of GI bleeding',
      clinicalEffect: 'Significantly increased risk of major bleeding, including intracranial hemorrhage',
      recommendation: 'Avoid combination if possible. If necessary, use lowest effective aspirin dose and monitor INR closely.',
      documentation: 'excellent',
      alternatives: [
        { name: 'Acetaminophen', rationale: 'For pain relief without antiplatelet effects' }
      ]
    },
    'ibuprofen': {
      severity: 'severe',
      mechanism: 'NSAIDs inhibit platelet function and may displace warfarin from protein binding',
      clinicalEffect: 'Increased risk of GI bleeding and elevated INR',
      recommendation: 'Avoid NSAIDs. Use acetaminophen for pain. If NSAID required, use shortest duration and monitor INR.',
      documentation: 'excellent',
      alternatives: [
        { name: 'Acetaminophen', rationale: 'Safer alternative for pain management' },
        { name: 'Topical NSAIDs', rationale: 'Lower systemic absorption' }
      ]
    },
    'metronidazole': {
      severity: 'moderate',
      mechanism: 'Metronidazole inhibits CYP2C9-mediated warfarin metabolism',
      clinicalEffect: 'Increased warfarin effect and risk of bleeding',
      recommendation: 'Monitor INR closely. May need to reduce warfarin dose by 25-50%.',
      documentation: 'good',
      alternatives: []
    }
  },
  'lisinopril': {
    'potassium': {
      severity: 'moderate',
      mechanism: 'ACE inhibitors reduce aldosterone, decreasing potassium excretion',
      clinicalEffect: 'Risk of hyperkalemia, especially in renal impairment',
      recommendation: 'Monitor serum potassium regularly. Avoid potassium supplements unless documented hypokalemia.',
      documentation: 'excellent',
      alternatives: []
    },
    'spironolactone': {
      severity: 'moderate',
      mechanism: 'Both drugs increase serum potassium through different mechanisms',
      clinicalEffect: 'Significantly increased risk of hyperkalemia',
      recommendation: 'Monitor potassium closely, especially in elderly or renal impairment. Start spironolactone at low dose.',
      documentation: 'excellent',
      alternatives: [
        { name: 'Furosemide', rationale: 'Loop diuretic without potassium-sparing effect' }
      ]
    }
  },
  'metformin': {
    'contrast': {
      severity: 'severe',
      mechanism: 'IV contrast can cause acute kidney injury, increasing metformin accumulation',
      clinicalEffect: 'Risk of lactic acidosis',
      recommendation: 'Hold metformin before contrast administration. Resume 48 hours after if renal function stable.',
      documentation: 'excellent',
      alternatives: []
    }
  },
  'simvastatin': {
    'amiodarone': {
      severity: 'severe',
      mechanism: 'Amiodarone inhibits CYP3A4, increasing simvastatin levels',
      clinicalEffect: 'Increased risk of myopathy and rhabdomyolysis',
      recommendation: 'Do not exceed simvastatin 20mg daily with amiodarone. Consider alternative statin.',
      documentation: 'excellent',
      alternatives: [
        { name: 'Pravastatin', rationale: 'Not metabolized by CYP3A4' },
        { name: 'Rosuvastatin', rationale: 'Minimal CYP3A4 metabolism' }
      ]
    },
    'clarithromycin': {
      severity: 'contraindicated',
      mechanism: 'Strong CYP3A4 inhibition dramatically increases statin levels',
      clinicalEffect: 'High risk of rhabdomyolysis',
      recommendation: 'Contraindicated. Hold statin during clarithromycin course or use azithromycin instead.',
      documentation: 'excellent',
      alternatives: [
        { name: 'Azithromycin', rationale: 'Does not inhibit CYP3A4' }
      ]
    }
  }
};

// Mock allergy database
const ALLERGY_DATABASE: Record = {
  'penicillin': {
    crossReactive: ['amoxicillin', 'ampicillin', 'piperacillin'],
    reactionType: 'Anaphylaxis risk'
  },
  'sulfa': {
    crossReactive: ['sulfamethoxazole', 'sulfasalazine', 'celecoxib'],
    reactionType: 'Hypersensitivity reaction'
  },
  'nsaid': {
    crossReactive: ['ibuprofen', 'naproxen', 'aspirin', 'ketorolac'],
    reactionType: 'Bronchospasm, urticaria'
  }
};

export const drugInteractionMockApi = {
  checkInteraction: async (
    newMedication: Partial,
    currentMedications: Medication[],
    allergies: string[],
    conditions: string[]
  ): Promise => {
    await new Promise(resolve => setTimeout(resolve, 800));

    const newMed: Medication = {
      id: uuidv4(),
      name: newMedication.name || '',
      genericName: newMedication.genericName || newMedication.name || '',
      dosage: newMedication.dosage || '',
      frequency: newMedication.frequency || '',
      route: newMedication.route || 'PO',
      startDate: new Date().toISOString(),
      prescriber: 'Current User',
      status: 'pending'
    };

    const drugInteractions: DrugInteraction[] = [];
    const allergyInteractions: AllergyInteraction[] = [];
    const conditionInteractions: ConditionInteraction[] = [];

    // Check drug-drug interactions
    const newDrugLower = newMed.genericName.toLowerCase();
    currentMedications.forEach(med => {
      const currentDrugLower = med.genericName.toLowerCase();
      
      // Check both directions
      const interaction = 
        INTERACTION_DATABASE[newDrugLower]?.[currentDrugLower] ||
        INTERACTION_DATABASE[currentDrugLower]?.[newDrugLower];
      
      if (interaction) {
        drugInteractions.push({
          id: uuidv4(),
          drug1: { name: newMed.name, id: newMed.id },
          drug2: { name: med.name, id: med.id },
          ...interaction
        });
      }
    });

    // Check allergy interactions
    allergies.forEach(allergy => {
      const allergyLower = allergy.toLowerCase();
      const allergyInfo = ALLERGY_DATABASE[allergyLower];
      
      if (allergyInfo?.crossReactive.some(drug => 
        newDrugLower.includes(drug) || drug.includes(newDrugLower)
      )) {
        allergyInteractions.push({
          id: uuidv4(),
          drug: { name: newMed.name, id: newMed.id },
          allergen: allergy,
          reactionType: allergyInfo.reactionType,
          severity: 'severe',
          crossReactivity: true,
          recommendation: `Patient has documented ${allergy} allergy. This medication may cause cross-reactivity.`
        });
      }
    });

    // Check condition contraindications
    if (conditions.includes('chronic kidney disease') && 
        ['metformin', 'nsaid', 'ibuprofen', 'naproxen'].some(d => newDrugLower.includes(d))) {
      conditionInteractions.push({
        id: uuidv4(),
        drug: { name: newMed.name, id: newMed.id },
        condition: 'Chronic Kidney Disease',
        severity: newDrugLower.includes('metformin') ? 'contraindicated' : 'severe',
        clinicalConcern: 'May worsen renal function or accumulate in kidney disease',
        recommendation: 'Assess renal function. Consider dose adjustment or alternative medication.'
      });
    }

    // Determine overall risk
    let overallRisk: InteractionCheckResult['overallRisk'] = 'none';
    let requiresOverride = false;

    if (drugInteractions.some(i => i.severity === 'contraindicated') ||
        allergyInteractions.some(i => i.severity === 'severe') ||
        conditionInteractions.some(i => i.severity === 'contraindicated')) {
      overallRisk = 'high';
      requiresOverride = true;
    } else if (drugInteractions.some(i => i.severity === 'severe') ||
               conditionInteractions.some(i => i.severity === 'severe')) {
      overallRisk = 'moderate';
      requiresOverride = true;
    } else if (drugInteractions.some(i => i.severity === 'moderate') ||
               conditionInteractions.some(i => i.severity === 'moderate')) {
      overallRisk = 'moderate';
    } else if (drugInteractions.length > 0 || 
               allergyInteractions.length > 0 || 
               conditionInteractions.length > 0) {
      overallRisk = 'low';
    }

    return {
      checkId: uuidv4(),
      timestamp: new Date().toISOString(),
      newMedication: newMed,
      drugInteractions,
      allergyInteractions,
      conditionInteractions,
      overallRisk,
      canProceed: overallRisk !== 'high',
      requiresOverride
    };
  },

  getAlternatives: async (
    medication: string,
    indication: string
  ): Promise => {
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Mock alternatives based on drug class
    const alternatives: Record = {
      'statin': [
        { name: 'Pravastatin', rationale: 'Minimal drug interactions, not CYP3A4 metabolized', interactions: 2 },
        { name: 'Rosuvastatin', rationale: 'Potent LDL reduction with fewer interactions', interactions: 3 }
      ],
      'nsaid': [
        { name: 'Acetaminophen', rationale: 'No antiplatelet effect, renal-safe', interactions: 1 },
        { name: 'Topical Diclofenac', rationale: 'Localized effect with minimal systemic absorption', interactions: 1 }
      ],
      'antibiotic': [
        { name: 'Azithromycin', rationale: 'Fewer drug interactions than macrolide alternatives', interactions: 2 }
      ]
    };

    return alternatives[indication] || [];
  },

  getPatientMedications: async (patientId: string): Promise => {
    await new Promise(resolve => setTimeout(resolve, 400));

    return {
      medications: [
        {
          id: '1',
          name: 'Warfarin',
          genericName: 'warfarin',
          dosage: '5mg',
          frequency: 'Once daily',
          route: 'PO',
          startDate: '2024-01-15',
          prescriber: 'Dr. Smith',
          status: 'active'
        },
        {
          id: '2',
          name: 'Lisinopril',
          genericName: 'lisinopril',
          dosage: '10mg',
          frequency: 'Once daily',
          route: 'PO',
          startDate: '2023-06-01',
          prescriber: 'Dr. Johnson',
          status: 'active'
        },
        {
          id: '3',
          name: 'Metformin',
          genericName: 'metformin',
          dosage: '500mg',
          frequency: 'Twice daily',
          route: 'PO',
          startDate: '2023-03-20',
          prescriber: 'Dr. Williams',
          status: 'active'
        },
        {
          id: '4',
          name: 'Simvastatin',
          genericName: 'simvastatin',
          dosage: '40mg',
          frequency: 'Once daily at bedtime',
          route: 'PO',
          startDate: '2022-11-10',
          prescriber: 'Dr. Smith',
          status: 'active'
        }
      ],
      allergies: ['Penicillin', 'Sulfa'],
      conditions: ['Hypertension', 'Type 2 Diabetes', 'Hyperlipidemia', 'Atrial Fibrillation']
    };
  }
};
```

### Redux Slice

```typescript
// src/core/redux/drugInteractionSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { 
  drugInteractionMockApi, 
  Medication, 
  InteractionCheckResult 
} from '../api/mock/drugInteractionMockApi';

interface DrugInteractionState {
  patientMedications: Medication[];
  patientAllergies: string[];
  patientConditions: string[];
  currentCheck: InteractionCheckResult | null;
  isChecking: boolean;
  checkHistory: InteractionCheckResult[];
  overrideReason: string | null;
  error: string | null;
}

const initialState: DrugInteractionState = {
  patientMedications: [],
  patientAllergies: [],
  patientConditions: [],
  currentCheck: null,
  isChecking: false,
  checkHistory: [],
  overrideReason: null,
  error: null
};

export const loadPatientMedications = createAsyncThunk(
  'drugInteraction/loadMedications',
  async (patientId: string) => {
    return await drugInteractionMockApi.getPatientMedications(patientId);
  }
);

export const checkDrugInteraction = createAsyncThunk(
  'drugInteraction/check',
  async (
    { newMedication, currentMedications, allergies, conditions }: {
      newMedication: Partial;
      currentMedications: Medication[];
      allergies: string[];
      conditions: string[];
    }
  ) => {
    return await drugInteractionMockApi.checkInteraction(
      newMedication, 
      currentMedications, 
      allergies, 
      conditions
    );
  }
);

const drugInteractionSlice = createSlice({
  name: 'drugInteraction',
  initialState,
  reducers: {
    clearCurrentCheck: (state) => {
      state.currentCheck = null;
      state.overrideReason = null;
    },
    setOverrideReason: (state, action: PayloadAction) => {
      state.overrideReason = action.payload;
    },
    acknowledgeInteraction: (state, action: PayloadAction) => {
      if (state.currentCheck) {
        state.checkHistory.push(state.currentCheck);
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(loadPatientMedications.fulfilled, (state, action) => {
        state.patientMedications = action.payload.medications;
        state.patientAllergies = action.payload.allergies;
        state.patientConditions = action.payload.conditions;
      })
      .addCase(checkDrugInteraction.pending, (state) => {
        state.isChecking = true;
        state.error = null;
      })
      .addCase(checkDrugInteraction.fulfilled, (state, action) => {
        state.isChecking = false;
        state.currentCheck = action.payload;
      })
      .addCase(checkDrugInteraction.rejected, (state, action) => {
        state.isChecking = false;
        state.error = action.error.message || 'Interaction check failed';
      });
  }
});

export const { clearCurrentCheck, setOverrideReason, acknowledgeInteraction } = drugInteractionSlice.actions;
export default drugInteractionSlice.reducer;
```

### Main Drug Interaction Checker Component

```tsx
// src/feature-module/components/ai/drug-interaction/DrugInteractionChecker.tsx
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  Card,
  Input,
  Button,
  AutoComplete,
  Tag,
  Alert,
  Modal,
  List,
  Collapse,
  Badge,
  Tooltip,
  Form,
  Select,
  Row,
  Col,
  Divider,
  Space
} from 'antd';
import {
  SearchOutlined,
  WarningOutlined,
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  StopOutlined,
  MedicineBoxOutlined,
  AlertOutlined,
  SwapOutlined
} from '@ant-design/icons';
import {
  loadPatientMedications,
  checkDrugInteraction,
  clearCurrentCheck,
  setOverrideReason
} from '../../../../core/redux/drugInteractionSlice';
import { InteractionAlert } from './InteractionAlert';
import { MedicationReviewPanel } from './MedicationReviewPanel';
import { SeverityBadge } from './SeverityBadge';
import type { RootState, AppDispatch } from '../../../../core/redux/store';

const { Panel } = Collapse;
const { Option } = Select;
const { TextArea } = Input;

interface DrugInteractionCheckerProps {
  patientId: string;
  onPrescribe?: (medication: any, overrideReason?: string) => void;
}

// Mock drug search suggestions
const DRUG_SUGGESTIONS = [
  { value: 'Aspirin', genericName: 'aspirin', class: 'NSAID/Antiplatelet' },
  { value: 'Ibuprofen', genericName: 'ibuprofen', class: 'NSAID' },
  { value: 'Amiodarone', genericName: 'amiodarone', class: 'Antiarrhythmic' },
  { value: 'Clarithromycin', genericName: 'clarithromycin', class: 'Macrolide Antibiotic' },
  { value: 'Metronidazole', genericName: 'metronidazole', class: 'Antibiotic' },
  { value: 'Potassium Chloride', genericName: 'potassium', class: 'Electrolyte' },
  { value: 'Spironolactone', genericName: 'spironolactone', class: 'Diuretic' },
  { value: 'Amoxicillin', genericName: 'amoxicillin', class: 'Penicillin Antibiotic' }
];

export const DrugInteractionChecker: React.FC = ({
  patientId,
  onPrescribe
}) => {
  const dispatch = useDispatch();
  const {
    patientMedications,
    patientAllergies,
    patientConditions,
    currentCheck,
    isChecking,
    overrideReason
  } = useSelector((state: RootState) => state.drugInteraction);

  const [form] = Form.useForm();
  const [searchValue, setSearchValue] = useState('');
  const [selectedDrug, setSelectedDrug] = useState(null);
  const [showOverrideModal, setShowOverrideModal] = useState(false);

  useEffect(() => {
    dispatch(loadPatientMedications(patientId));
  }, [dispatch, patientId]);

  const handleDrugSelect = (value: string, option: any) => {
    const drug = DRUG_SUGGESTIONS.find(d => d.value === value);
    setSelectedDrug(drug || null);
    setSearchValue(value);
  };

  const handleCheckInteraction = async () => {
    if (!selectedDrug) return;

    const formValues = form.getFieldsValue();
    
    dispatch(checkDrugInteraction({
      newMedication: {
        name: selectedDrug.value,
        genericName: selectedDrug.genericName,
        dosage: formValues.dosage,
        frequency: formValues.frequency,
        route: formValues.route
      },
      currentMedications: patientMedications,
      allergies: patientAllergies,
      conditions: patientConditions
    }));
  };

  const handleProceed = () => {
    if (currentCheck?.requiresOverride) {
      setShowOverrideModal(true);
    } else {
      onPrescribe?.(currentCheck?.newMedication);
      dispatch(clearCurrentCheck());
    }
  };

  const handleOverrideConfirm = () => {
    onPrescribe?.(currentCheck?.newMedication, overrideReason || undefined);
    setShowOverrideModal(false);
    dispatch(clearCurrentCheck());
  };

  const getRiskIcon = (risk: string) => {
    switch (risk) {
      case 'high': return ;
      case 'moderate': return ;
      case 'low': return ;
      default: return ;
    }
  };

  return (
    
      
        {/* Left Column - Prescribe New Medication */}
        
          
                
                Prescribe New Medication
              
            }
          >
            {/* Drug Search */}
            
              
                <AutoComplete
                  value={searchValue}
                  options={DRUG_SUGGESTIONS.map(d => ({
                    value: d.value,
                    label: (
                      
                        {d.value}
                        {d.class}
                      
                    )
                  }))}
                  onSelect={handleDrugSelect}
                  onChange={setSearchValue}
                  placeholder="Search medication..."
                  size="large"
                  style={{ width: '100%' }}
                  filterOption={(input, option) =>
                    option?.value.toLowerCase().includes(input.toLowerCase())
                  }
                />
              

              
                
                  
                    
                  
                
                
                  
                    
                      Once daily
                      Twice daily
                      Three times daily
                      Every 6 hours
                      As needed (PRN)
                    
                  
                
                
                  
                    
                      Oral (PO)
                      Intravenous (IV)
                      Intramuscular (IM)
                      Subcutaneous (SC)
                      Topical
                    
                  
                
              

              }
                onClick={handleCheckInteraction}
                loading={isChecking}
                disabled={!selectedDrug}
                block
                size="large"
              >
                Check Interactions
              
            

            {/* Interaction Results */}
            {currentCheck && (
              
                
                
                {/* Overall Risk Banner */}
                <Alert
                  type={
                    currentCheck.overallRisk === 'high' ? 'error' :
                    currentCheck.overallRisk === 'moderate' ? 'warning' :
                    currentCheck.overallRisk === 'low' ? 'info' : 'success'
                  }
                  icon={getRiskIcon(currentCheck.overallRisk)}
                  message={
                    
                      
                        Overall Risk: 
                        {currentCheck.overallRisk.toUpperCase()}
                      
                      
                        {currentCheck.drugInteractions.length > 0 && (
                          
                            {currentCheck.drugInteractions.length} Drug Interaction(s)
                          
                        )}
                        {currentCheck.allergyInteractions.length > 0 && (
                          
                            {currentCheck.allergyInteractions.length} Allergy Alert(s)
                          
                        )}
                        {currentCheck.conditionInteractions.length > 0 && (
                          
                            {currentCheck.conditionInteractions.length} Condition Warning(s)
                          
                        )}
                      
                    
                  }
                  showIcon
                  className="mb-4"
                />

                {/* Detailed Interactions */}
                <Collapse defaultActiveKey={['drugs', 'allergies', 'conditions']}>
                  {/* Drug-Drug Interactions */}
                  {currentCheck.drugInteractions.length > 0 && (
                    
                          
                            
                            Drug-Drug Interactions
                          
                        
                      }
                      key="drugs"
                    >
                      {currentCheck.drugInteractions.map((interaction) => (
                        
                      ))}
                    
                  )}

                  {/* Allergy Alerts */}
                  {currentCheck.allergyInteractions.length > 0 && (
                    
                          
                            
                            Allergy Alerts
                          
                        
                      }
                      key="allergies"
                    >
                      {currentCheck.allergyInteractions.map((interaction) => (
                        
                      ))}
                    
                  )}

                  {/* Condition Contraindications */}
                  {currentCheck.conditionInteractions.length > 0 && (
                    
                          
                            
                            Condition Contraindications
                          
                        
                      }
                      key="conditions"
                    >
                      {currentCheck.conditionInteractions.map((interaction) => (
                        
                      ))}
                    
                  )}
                

                {/* No Interactions Found */}
                {currentCheck.overallRisk === 'none' && (
                  }
                  />
                )}

                {/* Action Buttons */}
                
                  <Button onClick={() => dispatch(clearCurrentCheck())}>
                    Cancel
                  
                  
                    {currentCheck.requiresOverride ? 'Override & Prescribe' : 'Prescribe Medication'}
                  
                
              
            )}
          
        

        {/* Right Column - Patient Medication Review */}
        
          
        
      

      {/* Override Confirmation Modal */}
      
            
            Override Required
          
        }
        open={showOverrideModal}
        onCancel={() => setShowOverrideModal(false)}
        footer={[
          <Button key="cancel" onClick={() => setShowOverrideModal(false)}>
            Cancel
          ,
          
            Confirm Override
          
        ]}
      >
        
        
        
          
            <TextArea
              rows={4}
              placeholder="Enter clinical reason for override..."
              value={overrideReason || ''}
              onChange={(e) => dispatch(setOverrideReason(e.target.value))}
            />
          
        

        
      
    
  );
};
```

### Interaction Alert Component

```tsx
// src/feature-module/components/ai/drug-interaction/InteractionAlert.tsx
import React from 'react';
import { Card, Tag, Divider, List, Button, Tooltip } from 'antd';
import { 
  SwapOutlined, 
  InfoCircleOutlined,
  BookOutlined 
} from '@ant-design/icons';
import { SeverityBadge } from './SeverityBadge';
import type { 
  DrugInteraction, 
  AllergyInteraction, 
  ConditionInteraction 
} from '../../../../core/api/mock/drugInteractionMockApi';

interface InteractionAlertProps {
  interaction: DrugInteraction | AllergyInteraction | ConditionInteraction;
  type: 'drug' | 'allergy' | 'condition';
}

export const InteractionAlert: React.FC = ({
  interaction,
  type
}) => {
  const renderDrugInteraction = (i: DrugInteraction) => (
    
      
        
          {i.drug1.name}
          
          {i.drug2.name}
        
        
      

      
        
          Mechanism:
          {i.mechanism}
        
        
        
          Clinical Effect:
          {i.clinicalEffect}
        
        
        
          Recommendation:
          {i.recommendation}
        

        
          
            }>
              Documentation: {i.documentation}
            
          
        

        {i.alternatives.length > 0 && (
          <>
            
            
              Safer Alternatives:
              <List
                size="small"
                dataSource={i.alternatives}
                renderItem={(alt) => (
                  
                    {alt.name}
                    {alt.rationale}
                  
                )}
              />
            
          </>
        )}
      
    
  );

  const renderAllergyInteraction = (i: AllergyInteraction) => (
    
      
        
          {i.drug.name}
          ‚ö†Ô∏è
          Allergy: {i.allergen}
        
        
      

      
        
          Reaction Type:
          {i.reactionType}
        
        
        {i.crossReactivity && (
          
            Cross-Reactivity Risk
          
        )}
        
        
          Recommendation:
          {i.recommendation}
        
      
    
  );

  const renderConditionInteraction = (i: ConditionInteraction) => (
    
      
        
          {i.drug.name}
          ‚öïÔ∏è
          {i.condition}
        
        
      

      
        
          Clinical Concern:
          {i.clinicalConcern}
        
        
        
          Recommendation:
          {i.recommendation}
        
      
    
  );

  switch (type) {
    case 'drug':
      return renderDrugInteraction(interaction as DrugInteraction);
    case 'allergy':
      return renderAllergyInteraction(interaction as AllergyInteraction);
    case 'condition':
      return renderConditionInteraction(interaction as ConditionInteraction);
    default:
      return null;
  }
};
```

### Severity Badge Component

```tsx
// src/feature-module/components/ai/drug-interaction/SeverityBadge.tsx
import React from 'react';
import { Tag, Tooltip } from 'antd';
import {
  StopOutlined,
  ExclamationCircleOutlined,
  WarningOutlined,
  InfoCircleOutlined
} from '@ant-design/icons';

interface SeverityBadgeProps {
  severity: 'contraindicated' | 'severe' | 'moderate' | 'minor' | 'mild' | 'low';
}

const SEVERITY_CONFIG = {
  contraindicated: {
    color: '#F44336',
    bgColor: '#ffebee',
    icon: ,
    label: 'CONTRAINDICATED',
    description: 'Should not be used together under any circumstances'
  },
  severe: {
    color: '#E53935',
    bgColor: '#ffcdd2',
    icon: ,
    label: 'SEVERE',
    description: 'May cause life-threatening effects or require intervention'
  },
  moderate: {
    color: '#FF9800',
    bgColor: '#fff3e0',
    icon: ,
    label: 'MODERATE',
    description: 'May cause clinical deterioration; monitoring recommended'
  },
  minor: {
    color: '#FFC107',
    bgColor: '#fffde7',
    icon: ,
    label: 'MINOR',
    description: 'Limited clinical significance; be aware'
  },
  mild: {
    color: '#4CAF50',
    bgColor: '#e8f5e9',
    icon: ,
    label: 'MILD',
    description: 'Minimal clinical significance'
  },
  low: {
    color: '#4CAF50',
    bgColor: '#e8f5e9',
    icon: ,
    label: 'LOW',
    description: 'Minimal clinical significance'
  }
};

export const SeverityBadge: React.FC = ({ severity }) => {
  const config = SEVERITY_CONFIG[severity] || SEVERITY_CONFIG.minor;

  return (
    
      
        {config.label}
      
    
  );
};
```

### Medication Review Panel Component

```tsx
// src/feature-module/components/ai/drug-interaction/MedicationReviewPanel.tsx
import React from 'react';
import { Card, List, Tag, Divider, Empty } from 'antd';
import {
  MedicineBoxOutlined,
  AlertOutlined,
  HeartOutlined,
  CheckCircleOutlined
} from '@ant-design/icons';
import type { Medication } from '../../../../core/api/mock/drugInteractionMockApi';

interface MedicationReviewPanelProps {
  medications: Medication[];
  allergies: string[];
  conditions: string[];
}

export const MedicationReviewPanel: React.FC = ({
  medications,
  allergies,
  conditions
}) => {
  return (
    
      {/* Current Medications */}
      
            
            Current Medications ({medications.length})
          
        }
        className="mb-3"
        size="small"
      >
        {medications.length === 0 ? (
          
        ) : (
          <List
            size="small"
            dataSource={medications}
            renderItem={(med) => (
              
                <List.Item.Meta
                  avatar={
                    <Tag color={med.status === 'active' ? 'green' : 'default'}>
                      {med.status === 'active' ?  : null}
                    
                  }
                  title={{med.name}}
                  description={
                    
                      {med.dosage} ‚Ä¢ {med.frequency}
                      
                      
                        Prescribed by {med.prescriber}
                      
                    
                  }
                />
              
            )}
          />
        )}
      

      {/* Allergies */}
      
            
            Known Allergies ({allergies.length})
          
        }
        className="mb-3"
        size="small"
      >
        {allergies.length === 0 ? (
          No Known Allergies (NKDA)
        ) : (
          
            {allergies.map((allergy, idx) => (
              
                {allergy}
              
            ))}
          
        )}
      

      {/* Active Conditions */}
      
            
            Active Conditions ({conditions.length})
          
        }
        size="small"
      >
        {conditions.length === 0 ? (
          
        ) : (
          
            {conditions.map((condition, idx) => (
              
                {condition}
              
            ))}
          
        )}
      
    
  );
};
```

### Success Metrics

- ‚úÖ 80% reduction in preventable adverse drug events
- ‚úÖ 95% of significant interactions caught before prescribing
- ‚úÖ 50% reduction in time spent manually reviewing drug interactions
- ‚úÖ 100% audit trail compliance for interaction overrides

---
```

```markdown
## Feature 9: Voice Documentation Assistant

### Problem Statement

Physicians spend 2+ hours daily on documentation, reducing patient face time. Manual typing is slow and error-prone. Medical terminology requires specialized input methods. Current systems don't support hands-free documentation during patient encounters.

### AI Solution

Real-time speech-to-text system with medical terminology recognition, automatic structuring into SOAP notes, ICD-10 code suggestions, and intelligent field population. Supports continuous dictation with pause/resume and post-dictation editing.

### Technical Requirements

| Component | Description |
|-----------|-------------|
| **React Components** | `VoiceRecorder.tsx`, `TranscriptionEditor.tsx`, `NoteFormatter.tsx`, `MedicalTermsHighlighter.tsx` |
| **Redux Slice** | `voiceDocSlice.ts` (recording state, transcription, SOAP structure) |
| **API Endpoints** | `POST /api/voice/transcribe`, `POST /api/voice/structure`, `GET /api/voice/suggestions` |
| **AI Integration** | Whisper API for transcription, GPT-4 for structuring, medical NER model |

### Mock API Engine

```typescript
// src/core/api/mock/voiceDocMockApi.ts
import { v4 as uuidv4 } from 'uuid';

export interface TranscriptionResult {
  id: string;
  text: string;
  confidence: number;
  medicalTerms: {
    term: string;
    type: 'diagnosis' | 'medication' | 'procedure' | 'symptom' | 'anatomy';
    position: { start: number; end: number };
    icdCode?: string;
    cptCode?: string;
  }[];
  duration: number;
}

export interface SOAPNote {
  subjective: string;
  objective: string;
  assessment: string;
  plan: string;
  icdCodes: { code: string; description: string; confidence: number }[];
  cptCodes: { code: string; description: string }[];
}

export interface VoiceSession {
  sessionId: string;
  patientId: string;
  startTime: string;
  transcriptions: TranscriptionResult[];
  structuredNote: SOAPNote | null;
  status: 'recording' | 'processing' | 'completed' | 'error';
}

// Medical term database for highlighting
const MEDICAL_TERMS_DB = {
  diagnoses: [
    { term: 'hypertension', icd: 'I10', type: 'diagnosis' },
    { term: 'type 2 diabetes', icd: 'E11.9', type: 'diagnosis' },
    { term: 'pneumonia', icd: 'J18.9', type: 'diagnosis' },
    { term: 'congestive heart failure', icd: 'I50.9', type: 'diagnosis' },
    { term: 'COPD', icd: 'J44.9', type: 'diagnosis' },
    { term: 'atrial fibrillation', icd: 'I48.91', type: 'diagnosis' },
    { term: 'chronic kidney disease', icd: 'N18.9', type: 'diagnosis' }
  ],
  medications: [
    { term: 'metformin', type: 'medication' },
    { term: 'lisinopril', type: 'medication' },
    { term: 'atorvastatin', type: 'medication' },
    { term: 'metoprolol', type: 'medication' },
    { term: 'omeprazole', type: 'medication' },
    { term: 'amlodipine', type: 'medication' }
  ],
  symptoms: [
    { term: 'chest pain', type: 'symptom' },
    { term: 'shortness of breath', type: 'symptom' },
    { term: 'fatigue', type: 'symptom' },
    { term: 'headache', type: 'symptom' },
    { term: 'nausea', type: 'symptom' },
    { term: 'dizziness', type: 'symptom' }
  ]
};

// Simulated transcription responses
const MOCK_TRANSCRIPTIONS = [
  {
    text: "Patient is a 65-year-old male presenting with complaints of chest pain and shortness of breath for the past two days. He has a history of hypertension and type 2 diabetes. Currently taking metformin 500 milligrams twice daily and lisinopril 10 milligrams daily.",
    duration: 15
  },
  {
    text: "On physical examination, blood pressure is 145 over 92, heart rate 88, respiratory rate 18, oxygen saturation 94% on room air. Lungs have bilateral crackles at the bases. Heart sounds regular with no murmurs. Mild lower extremity edema noted bilaterally.",
    duration: 18
  },
  {
    text: "Assessment: Likely acute exacerbation of congestive heart failure. Differential includes pneumonia given the bilateral crackles. Plan: Obtain chest x-ray, BNP, and basic metabolic panel. Start IV Lasix 40 milligrams. Consider cardiology consult if no improvement.",
    duration: 14
  }
];

// Find medical terms in text
const findMedicalTerms = (text: string): TranscriptionResult['medicalTerms'] => {
  const terms: TranscriptionResult['medicalTerms'] = [];
  const lowerText = text.toLowerCase();
  
  Object.values(MEDICAL_TERMS_DB).flat().forEach(item => {
    const index = lowerText.indexOf(item.term.toLowerCase());
    if (index !== -1) {
      terms.push({
        term: item.term,
        type: item.type as any,
        position: { start: index, end: index + item.term.length },
        icdCode: 'icd' in item ? item.icd : undefined
      });
    }
  });
  
  return terms;
};

// Generate SOAP note from transcriptions
const generateSOAPNote = (transcriptions: TranscriptionResult[]): SOAPNote => {
  const fullText = transcriptions.map(t => t.text).join(' ');
  
  return {
    subjective: "65-year-old male with chief complaint of chest pain and shortness of breath x 2 days. History of HTN and T2DM. Current medications: Metformin 500mg BID, Lisinopril 10mg daily. Patient reports symptoms worsening with exertion, improving with rest. Denies fever, cough, or recent illness.",
    objective: "VS: BP 145/92, HR 88, RR 18, SpO2 94% RA\nGeneral: Alert, oriented, mild respiratory distress\nLungs: Bilateral basilar crackles\nCardiac: RRR, no murmurs/gallops\nExtremities: 1+ bilateral LE edema\nNeuro: Grossly intact",
    assessment: "1. Acute on chronic systolic heart failure exacerbation (I50.9)\n2. Hypertension, uncontrolled (I10)\n3. Type 2 diabetes mellitus (E11.9)",
    plan: "1. IV Furosemide 40mg x1, then reassess\n2. Chest X-ray PA/Lateral\n3. Labs: BMP, BNP, CBC\n4. Cardiology consult if no improvement in 24h\n5. Daily weights, I/O monitoring\n6. Sodium restriction <2g/day",
    icdCodes: [
      { code: 'I50.9', description: 'Heart failure, unspecified', confidence: 0.95 },
      { code: 'I10', description: 'Essential hypertension', confidence: 0.90 },
      { code: 'E11.9', description: 'Type 2 diabetes without complications', confidence: 0.88 }
    ],
    cptCodes: [
      { code: '99223', description: 'Initial hospital care, high complexity' },
      { code: '71046', description: 'Chest X-ray, 2 views' }
    ]
  };
};

export const voiceDocMockApi = {
  startSession: async (patientId: string): Promise => {
    await new Promise(resolve => setTimeout(resolve, 300));
    return {
      sessionId: uuidv4(),
      patientId,
      startTime: new Date().toISOString(),
      transcriptions: [],
      structuredNote: null,
      status: 'recording'
    };
  },

  transcribeAudio: async (sessionId: string, audioBlob: Blob): Promise => {
    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Return mock transcription (in real implementation, send to Whisper API)
    const mockIndex = Math.floor(Math.random() * MOCK_TRANSCRIPTIONS.length);
    const mock = MOCK_TRANSCRIPTIONS[mockIndex];
    
    return {
      id: uuidv4(),
      text: mock.text,
      confidence: 0.92 + Math.random() * 0.07,
      medicalTerms: findMedicalTerms(mock.text),
      duration: mock.duration
    };
  },

  structureNote: async (transcriptions: TranscriptionResult[]): Promise => {
    await new Promise(resolve => setTimeout(resolve, 2000));
    return generateSOAPNote(transcriptions);
  },

  getSuggestions: async (text: string): Promise => {
    await new Promise(resolve => setTimeout(resolve, 500));
    return {
      corrections: [
        { original: 'metaformin', suggested: 'metformin', type: 'spelling' },
        { original: 'lisinapril', suggested: 'lisinopril', type: 'spelling' }
      ],
      completions: [
        'Consider adding ACE inhibitor',
        'Recommend echocardiogram if not done recently',
        'Follow up in 2 weeks'
      ]
    };
  },

  saveNote: async (sessionId: string, note: SOAPNote): Promise => {
    await new Promise(resolve => setTimeout(resolve, 500));
    return {
      success: true,
      noteId: uuidv4()
    };
  }
};
```

### Redux Slice

```typescript
// src/core/redux/voiceDocSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { 
  voiceDocMockApi, 
  VoiceSession, 
  TranscriptionResult, 
  SOAPNote 
} from '../api/mock/voiceDocMockApi';

interface VoiceDocState {
  currentSession: VoiceSession | null;
  isRecording: boolean;
  isProcessing: boolean;
  isPaused: boolean;
  transcriptions: TranscriptionResult[];
  structuredNote: SOAPNote | null;
  editedNote: SOAPNote | null;
  recordingDuration: number;
  audioLevel: number;
  error: string | null;
  suggestions: {
    corrections: { original: string; suggested: string; type: string }[];
    completions: string[];
  } | null;
}

const initialState: VoiceDocState = {
  currentSession: null,
  isRecording: false,
  isProcessing: false,
  isPaused: false,
  transcriptions: [],
  structuredNote: null,
  editedNote: null,
  recordingDuration: 0,
  audioLevel: 0,
  error: null,
  suggestions: null
};

export const startVoiceSession = createAsyncThunk(
  'voiceDoc/startSession',
  async (patientId: string) => {
    return await voiceDocMockApi.startSession(patientId);
  }
);

export const transcribeAudio = createAsyncThunk(
  'voiceDoc/transcribe',
  async ({ sessionId, audioBlob }: { sessionId: string; audioBlob: Blob }) => {
    return await voiceDocMockApi.transcribeAudio(sessionId, audioBlob);
  }
);

export const structureNote = createAsyncThunk(
  'voiceDoc/structure',
  async (transcriptions: TranscriptionResult[]) => {
    return await voiceDocMockApi.structureNote(transcriptions);
  }
);

export const saveNote = createAsyncThunk(
  'voiceDoc/save',
  async ({ sessionId, note }: { sessionId: string; note: SOAPNote }) => {
    return await voiceDocMockApi.saveNote(sessionId, note);
  }
);

const voiceDocSlice = createSlice({
  name: 'voiceDoc',
  initialState,
  reducers: {
    setRecording: (state, action: PayloadAction) => {
      state.isRecording = action.payload;
    },
    setPaused: (state, action: PayloadAction) => {
      state.isPaused = action.payload;
    },
    updateAudioLevel: (state, action: PayloadAction) => {
      state.audioLevel = action.payload;
    },
    updateDuration: (state, action: PayloadAction) => {
      state.recordingDuration = action.payload;
    },
    updateEditedNote: (state, action: PayloadAction<Partial>) => {
      if (state.editedNote) {
        state.editedNote = { ...state.editedNote, ...action.payload };
      }
    },
    clearSession: (state) => {
      state.currentSession = null;
      state.transcriptions = [];
      state.structuredNote = null;
      state.editedNote = null;
      state.recordingDuration = 0;
      state.isRecording = false;
      state.isPaused = false;
    },
    addManualTranscription: (state, action: PayloadAction) => {
      const newTranscription: TranscriptionResult = {
        id: Date.now().toString(),
        text: action.payload,
        confidence: 1.0,
        medicalTerms: [],
        duration: 0
      };
      state.transcriptions.push(newTranscription);
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(startVoiceSession.fulfilled, (state, action) => {
        state.currentSession = action.payload;
        state.transcriptions = [];
        state.structuredNote = null;
        state.editedNote = null;
      })
      .addCase(transcribeAudio.pending, (state) => {
        state.isProcessing = true;
      })
      .addCase(transcribeAudio.fulfilled, (state, action) => {
        state.isProcessing = false;
        state.transcriptions.push(action.payload);
      })
      .addCase(transcribeAudio.rejected, (state, action) => {
        state.isProcessing = false;
        state.error = action.error.message || 'Transcription failed';
      })
      .addCase(structureNote.pending, (state) => {
        state.isProcessing = true;
      })
      .addCase(structureNote.fulfilled, (state, action) => {
        state.isProcessing = false;
        state.structuredNote = action.payload;
        state.editedNote = action.payload;
      })
      .addCase(saveNote.fulfilled, (state) => {
        state.currentSession = null;
      });
  }
});

export const { 
  setRecording, 
  setPaused, 
  updateAudioLevel, 
  updateDuration,
  updateEditedNote,
  clearSession,
  addManualTranscription 
} = voiceDocSlice.actions;

export default voiceDocSlice.reducer;
```

### Voice Recognition Hook

```typescript
// src/core/hooks/useVoiceRecognition.ts
import { useState, useEffect, useRef, useCallback } from 'react';

interface UseVoiceRecognitionOptions {
  onResult?: (transcript: string) => void;
  onError?: (error: string) => void;
  continuous?: boolean;
  interimResults?: boolean;
}

interface UseVoiceRecognitionReturn {
  isListening: boolean;
  isSupported: boolean;
  transcript: string;
  interimTranscript: string;
  startListening: () => void;
  stopListening: () => void;
  resetTranscript: () => void;
  audioLevel: number;
}

export const useVoiceRecognition = (
  options: UseVoiceRecognitionOptions = {}
): UseVoiceRecognitionReturn => {
  const { onResult, onError, continuous = true, interimResults = true } = options;
  
  const [isListening, setIsListening] = useState(false);
  const [transcript, setTranscript] = useState('');
  const [interimTranscript, setInterimTranscript] = useState('');
  const [audioLevel, setAudioLevel] = useState(0);
  
  const recognitionRef = useRef(null);
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const animationRef = useRef(null);

  const isSupported = typeof window !== 'undefined' && 
    ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window);

  // Initialize speech recognition
  useEffect(() => {
    if (!isSupported) return;

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognitionRef.current = new SpeechRecognition();
    recognitionRef.current.continuous = continuous;
    recognitionRef.current.interimResults = interimResults;
    recognitionRef.current.lang = 'en-US';

    recognitionRef.current.onresult = (event) => {
      let finalTranscript = '';
      let interimText = '';

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const result = event.results[i];
        if (result.isFinal) {
          finalTranscript += result[0].transcript;
        } else {
          interimText += result[0].transcript;
        }
      }

      if (finalTranscript) {
        setTranscript(prev => prev + ' ' + finalTranscript);
        onResult?.(finalTranscript);
      }
      setInterimTranscript(interimText);
    };

    recognitionRef.current.onerror = (event) => {
      onError?.(event.error);
      setIsListening(false);
    };

    recognitionRef.current.onend = () => {
      if (isListening && continuous) {
        recognitionRef.current?.start();
      }
    };

    return () => {
      recognitionRef.current?.stop();
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isSupported, continuous, interimResults, onResult, onError, isListening]);

  // Audio level monitoring
  const startAudioMonitoring = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioContextRef.current = new AudioContext();
      analyserRef.current = audioContextRef.current.createAnalyser();
      const source = audioContextRef.current.createMediaStreamSource(stream);
      source.connect(analyserRef.current);
      analyserRef.current.fftSize = 256;

      const updateLevel = () => {
        if (!analyserRef.current) return;
        const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
        analyserRef.current.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
        setAudioLevel(average / 255);
        animationRef.current = requestAnimationFrame(updateLevel);
      };
      updateLevel();
    } catch (err) {
      console.error('Failed to access microphone:', err);
    }
  }, []);

  const stopAudioMonitoring = useCallback(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    audioContextRef.current?.close();
    setAudioLevel(0);
  }, []);

  const startListening = useCallback(() => {
    if (!isSupported || !recognitionRef.current) return;
    setIsListening(true);
    recognitionRef.current.start();
    startAudioMonitoring();
  }, [isSupported, startAudioMonitoring]);

  const stopListening = useCallback(() => {
    if (!recognitionRef.current) return;
    setIsListening(false);
    recognitionRef.current.stop();
    stopAudioMonitoring();
  }, [stopAudioMonitoring]);

  const resetTranscript = useCallback(() => {
    setTranscript('');
    setInterimTranscript('');
  }, []);

  return {
    isListening,
    isSupported,
    transcript,
    interimTranscript,
    startListening,
    stopListening,
    resetTranscript,
    audioLevel
  };
};
```

### Main Voice Recorder Component

```tsx
// src/feature-module/components/ai/voice-documentation/VoiceRecorder.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { 
  Card, 
  Button, 
  Progress, 
  Tag, 
  Space, 
  Tooltip, 
  Alert,
  Modal,
  Tabs,
  Row,
  Col
} from 'antd';
import {
  AudioOutlined,
  PauseCircleOutlined,
  PlayCircleOutlined,
  StopOutlined,
  SaveOutlined,
  EditOutlined,
  SoundOutlined,
  CheckCircleOutlined
} from '@ant-design/icons';
import { useVoiceRecognition } from '../../../../core/hooks/useVoiceRecognition';
import { 
  startVoiceSession,
  setRecording,
  setPaused,
  updateDuration,
  structureNote,
  clearSession,
  addManualTranscription
} from '../../../../core/redux/voiceDocSlice';
import { TranscriptionEditor } from './TranscriptionEditor';
import { NoteFormatter } from './NoteFormatter';
import { MedicalTermsHighlighter } from './MedicalTermsHighlighter';
import type { RootState, AppDispatch } from '../../../../core/redux/store';

const { TabPane } = Tabs;

interface VoiceRecorderProps {
  patientId: string;
  patientName: string;
  onSave?: (noteId: string) => void;
}

export const VoiceRecorder: React.FC = ({
  patientId,
  patientName,
  onSave
}) => {
  const dispatch = useDispatch();
  const {
    currentSession,
    isRecording,
    isPaused,
    isProcessing,
    transcriptions,
    structuredNote,
    recordingDuration,
    error
  } = useSelector((state: RootState) => state.voiceDoc);

  const [activeTab, setActiveTab] = useState('record');
  const [showPreview, setShowPreview] = useState(false);

  const {
    isListening,
    isSupported,
    transcript,
    interimTranscript,
    startListening,
    stopListening,
    resetTranscript,
    audioLevel
  } = useVoiceRecognition({
    onResult: (text) => {
      if (currentSession) {
        dispatch(addManualTranscription(text));
      }
    },
    onError: (err) => console.error('Voice recognition error:', err)
  });

  // Timer for recording duration
  useEffect(() => {
    let interval: NodeJS.Timeout;
    if (isRecording && !isPaused) {
      interval = setInterval(() => {
        dispatch(updateDuration(recordingDuration + 1));
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isRecording, isPaused, recordingDuration, dispatch]);

  const handleStartRecording = async () => {
    if (!currentSession) {
      await dispatch(startVoiceSession(patientId));
    }
    dispatch(setRecording(true));
    startListening();
  };

  const handlePauseRecording = () => {
    dispatch(setPaused(!isPaused));
    if (isPaused) {
      startListening();
    } else {
      stopListening();
    }
  };

  const handleStopRecording = async () => {
    dispatch(setRecording(false));
    stopListening();
    
    if (transcriptions.length > 0) {
      await dispatch(structureNote(transcriptions));
      setActiveTab('review');
    }
  };

  const handleClear = () => {
    dispatch(clearSession());
    resetTranscript();
  };

  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  if (!isSupported) {
    return (
      
    );
  }

  return (
    
      
        {/* Header */}
        
          
            
              
              Voice Documentation
            
            Patient: {patientName}
          
          
            {isRecording ? '‚óè Recording' : 'Ready'}
          
        

        
          {/* Recording Tab */}
          
            {/* Audio Visualization */}
            
              
                
              
              
              
                {formatDuration(recordingDuration)}
              
              
              {/* Audio Level Meter */}
              
            

            {/* Control Buttons */}
            
              
                {!isRecording ? (
                  
                    }
                      onClick={handleStartRecording}
                      style={{ width: 64, height: 64 }}
                    />
                  
                ) : (
                  <>
                    
                       : }
                        onClick={handlePauseRecording}
                        style={{ width: 56, height: 56 }}
                      />
                    
                    
                      }
                        onClick={handleStopRecording}
                        style={{ width: 64, height: 64 }}
                        loading={isProcessing}
                      />
                    
                  </>
                )}
              
            

            {/* Live Transcription Preview */}
            
              
                
                  
                  Live Transcription
                
                
                  {transcriptions.length} segment(s)
                
              
              
              
                {transcriptions.map((t, idx) => (
                  
                    
                  
                ))}
                {interimTranscript && (
                  {interimTranscript}...
                )}
                {transcriptions.length === 0 && !interimTranscript && (
                  
                    Start speaking to see transcription...
                  
                )}
              
            
          

          {/* Review & Edit Tab */}
          
            {structuredNote && (
              
            )}
          

          {/* Formatted Note Tab */}
          
            {structuredNote && (
              
            )}
          
        
      

      {/* Quick Actions */}
      
        
          Clear All
        
        }
          disabled={!structuredNote}
          onClick={() => setShowPreview(true)}
        >
          Save to Patient Record
        
      
    
  );
};
```

### Medical Terms Highlighter

```tsx
// src/feature-module/components/ai/voice-documentation/MedicalTermsHighlighter.tsx
import React from 'react';
import { Tooltip, Tag } from 'antd';

interface MedicalTerm {
  term: string;
  type: 'diagnosis' | 'medication' | 'procedure' | 'symptom' | 'anatomy';
  position: { start: number; end: number };
  icdCode?: string;
  cptCode?: string;
}

interface MedicalTermsHighlighterProps {
  text: string;
  medicalTerms: MedicalTerm[];
}

const TYPE_COLORS = {
  diagnosis: { bg: '#fff1f0', border: '#ffa39e', text: '#cf1322' },
  medication: { bg: '#e6f7ff', border: '#91d5ff', text: '#0050b3' },
  procedure: { bg: '#f6ffed', border: '#b7eb8f', text: '#389e0d' },
  symptom: { bg: '#fff7e6', border: '#ffd591', text: '#d46b08' },
  anatomy: { bg: '#f9f0ff', border: '#d3adf7', text: '#531dab' }
};

export const MedicalTermsHighlighter: React.FC = ({
  text,
  medicalTerms
}) => {
  if (!medicalTerms || medicalTerms.length === 0) {
    return {text};
  }

  // Sort terms by position
  const sortedTerms = [...medicalTerms].sort((a, b) => a.position.start - b.position.start);
  
  const elements: React.ReactNode[] = [];
  let lastIndex = 0;

  sortedTerms.forEach((term, idx) => {
    // Add text before this term
    if (term.position.start > lastIndex) {
      elements.push(
        
          {text.slice(lastIndex, term.position.start)}
        
      );
    }

    // Add highlighted term
    const colors = TYPE_COLORS[term.type];
    const tooltipContent = (
      
        {term.type.charAt(0).toUpperCase() + term.type.slice(1)}
        {term.icdCode && ICD-10: {term.icdCode}}
        {term.cptCode && CPT: {term.cptCode}}
      
    );

    elements.push(
      
        
          {text.slice(term.position.start, term.position.end)}
        
      
    );

    lastIndex = term.position.end;
  });

  // Add remaining text
  if (lastIndex < text.length) {
    elements.push(
      {text.slice(lastIndex)}
    );
  }

  return <>{elements}</>;
};
```

### Transcription Editor Component

```tsx
// src/feature-module/components/ai/voice-documentation/TranscriptionEditor.tsx
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { Card, Input, Button, Tag, List, Divider, Row, Col, Alert } from 'antd';
import { 
  EditOutlined, 
  CheckOutlined, 
  PlusOutlined,
  DeleteOutlined
} from '@ant-design/icons';
import { updateEditedNote, saveNote } from '../../../../core/redux/voiceDocSlice';
import type { SOAPNote } from '../../../../core/api/mock/voiceDocMockApi';
import type { AppDispatch } from '../../../../core/redux/store';

const { TextArea } = Input;

interface TranscriptionEditorProps {
  note: SOAPNote;
  onSave?: (noteId: string) => void;
}

export const TranscriptionEditor: React.FC = ({
  note,
  onSave
}) => {
  const dispatch = useDispatch();
  const [editMode, setEditMode] = useState(null);
  const [editedNote, setEditedNote] = useState(note);

  const handleFieldChange = (field: keyof SOAPNote, value: string) => {
    const updated = { ...editedNote, [field]: value };
    setEditedNote(updated);
    dispatch(updateEditedNote({ [field]: value }));
  };

  const soapSections = [
    { key: 'subjective', label: 'Subjective', color: '#F44336', icon: 'üí¨' },
    { key: 'objective', label: 'Objective', color: '#2196F3', icon: 'üîç' },
    { key: 'assessment', label: 'Assessment', color: '#FF9800', icon: 'üìã' },
    { key: 'plan', label: 'Plan', color: '#4CAF50', icon: 'üìù' }
  ];

  return (
    
      

      {/* SOAP Sections */}
      {soapSections.map((section) => (
        
          
            
              {section.icon} {section.label}
            
            <Button 
              size="small" 
              type="text"
              icon={editMode === section.key ?  : }
              onClick={() => setEditMode(editMode === section.key ? null : section.key)}
            />
          
          
          {editMode === section.key ? (
            <TextArea
              value={editedNote[section.key as keyof SOAPNote] as string}
              onChange={(e) => handleFieldChange(section.key as keyof SOAPNote, e.target.value)}
              autoSize={{ minRows: 3, maxRows: 8 }}
              onBlur={() => setEditMode(null)}
              autoFocus
            />
          ) : (
            
              {editedNote[section.key as keyof SOAPNote] as string}
            
          )}
        
      ))}

      

      {/* ICD-10 Codes */}
      
        
          üè∑Ô∏è Suggested ICD-10 Codes
        
        <List
          size="small"
          dataSource={note.icdCodes}
          renderItem={(item) => (
            }
                />
              ]}
            >
              
                {item.code}
                {item.description}
                 0.9 ? 'green' : 'orange'}>
                  {Math.round(item.confidence * 100)}% confident
                
              
            
          )}
        />
        } block className="mt-2">
          Add ICD-10 Code
        
      

      {/* CPT Codes */}
      
        
          üí∞ Suggested CPT Codes
        
        
          {note.cptCodes.map((cpt, idx) => (
            
              {cpt.code} - {cpt.description}
            
          ))}
          
             Add
          
        
      
    
  );
};
```

### Note Formatter Component

```tsx
// src/feature-module/components/ai/voice-documentation/NoteFormatter.tsx
import React, { useRef } from 'react';
import { Card, Button, Divider, Typography, Space } from 'antd';
import { 
  PrinterOutlined, 
  CopyOutlined, 
  FileTextOutlined,
  CheckOutlined
} from '@ant-design/icons';
import type { SOAPNote } from '../../../../core/api/mock/voiceDocMockApi';

const { Title, Text, Paragraph } = Typography;

interface NoteFormatterProps {
  note: SOAPNote;
  patientName: string;
}

export const NoteFormatter: React.FC = ({ note, patientName }) => {
  const printRef = useRef(null);
  const [copied, setCopied] = React.useState(false);

  const handlePrint = () => {
    const printContent = printRef.current?.innerHTML;
    const printWindow = window.open('', '_blank');
    if (printWindow && printContent) {
      printWindow.document.write(`
        
          
            Clinical Note - ${patientName}
            
              body { font-family: 'Times New Roman', serif; padding: 40px; }
              h1 { font-size: 18px; border-bottom: 2px solid #000; }
              h2 { font-size: 14px; color: #333; margin-top: 20px; }
              p { line-height: 1.6; }
              .codes { background: #f5f5f5; padding: 10px; margin-top: 20px; }
            
          
          ${printContent}
        
      `);
      printWindow.document.close();
      printWindow.print();
    }
  };

  const handleCopy = () => {
    const text = `
CLINICAL NOTE
Patient: ${patientName}
Date: ${new Date().toLocaleDateString()}

SUBJECTIVE:
${note.subjective}

OBJECTIVE:
${note.objective}

ASSESSMENT:
${note.assessment}

PLAN:
${note.plan}

ICD-10 CODES:
${note.icdCodes.map(c => `${c.code} - ${c.description}`).join('\n')}

CPT CODES:
${note.cptCodes.map(c => `${c.code} - ${c.description}`).join('\n')}
    `.trim();

    navigator.clipboard.writeText(text);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    
      {/* Action Buttons */}
      
        } onClick={handlePrint}>
          Print
        
         : }
          onClick={handleCopy}
        >
          {copied ? 'Copied!' : 'Copy to Clipboard'}
        
        }>
          Export to EHR
        
      

      {/* Formatted Note Preview */}
      
        
          CLINICAL NOTE
          
            Patient: {patientName} | Date: {new Date().toLocaleDateString()} | 
            Time: {new Date().toLocaleTimeString()}
          
        

        

        
          SUBJECTIVE
          {note.subjective}
        

        
          OBJECTIVE
          {note.objective}
        

        
          ASSESSMENT
          {note.assessment}
        

        
          PLAN
          {note.plan}
        

        

        
          BILLING CODES
          
            ICD-10 Codes:
            
              {note.icdCodes.map((code, idx) => (
                {code.code} - {code.description}
              ))}
            
          
          
            CPT Codes:
            
              {note.cptCodes.map((code, idx) => (
                {code.code} - {code.description}
              ))}
            
          
        

        

        
          
            Electronically signed by: ________________________
          
          
          
            Generated with AI assistance | Reviewed and approved by physician
          
        
      
    
  );
};
```

### Success Metrics

- ‚úÖ 60% reduction in documentation time (from 2+ hours to <45 min daily)
- ‚úÖ 95% accuracy in medical terminology transcription
- ‚úÖ 85% of generated notes require minimal editing
- ‚úÖ 90% physician satisfaction with voice documentation workflow

```